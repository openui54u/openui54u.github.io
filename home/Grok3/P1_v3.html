<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HomeWizard Dashboard</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        /* Custom styles for canvas and specific tweaks */
        canvas {
            max-width: 100%;
            height: auto;
        }
        .slider {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 8px;
            background: #d1d5db;
            outline: none;
            opacity: 0.7;
            transition: opacity .2s;
            border-radius: 9999px;
        }
        .slider:hover {
            opacity: 1;
        }
        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: #10b981;
            cursor: pointer;
            border-radius: 50%;
        }
        .slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: #10b981;
            cursor: pointer;
            border-radius: 50%;
        }
        .switch {
            position: relative;
            display: inline-block;
            width: 60px;
            height: 34px;
        }
        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        .sliderB {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 34px;
        }
        .sliderB:before {
            position: absolute;
            content: "";
            height: 26px;
            width: 26px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        input:checked + .sliderB {
            background-color: #3b82f6;
        }
        input:focus + .sliderB {
            box-shadow: 0 0 1px #3b82f6;
        }
        input:checked + .sliderB:before {
            transform: translateX(26px);
        }
    </style>
</head>
<body class="bg-gray-100 font-sans antialiased">
    <div class="container mx-auto p-4 max-w-7xl">
        <!-- Header -->
        <header class="mb-6 text-center">
            <h1 class="text-4xl font-bold text-gray-800">HomeWizard Dashboard</h1>
            <p class="text-sm text-gray-500">Real-time monitoring of your energy and water usage</p>
        </header>

        <!-- Controls Section -->
        <section class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-6">
            <div class="bg-white p-4 rounded-lg shadow-md">
                <label for="IP_P1" class="block text-sm font-medium text-gray-700">P1 Meter IP</label>
                <input type="text" id="IP_P1" name="IP_P1" required minlength="7" maxlength="15" class="mt-1 block w-full border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500">
            </div>
            <div class="bg-white p-4 rounded-lg shadow-md">
                <label for="IP_WTR" class="block text-sm font-medium text-gray-700">Water Meter IP</label>
                <input type="text" id="IP_WTR" name="IP_WTR" required minlength="7" maxlength="15" class="mt-1 block w-full border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500">
            </div>
            <div class="bg-white p-4 rounded-lg shadow-md">
                <label for="IP_KWH" class="block text-sm font-medium text-gray-700">kWh Meter IP</label>
                <input type="text" id="IP_KWH" name="IP_KWH" required minlength="7" maxlength="15" class="mt-1 block w-full border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500">
            </div>
        </section>

        <div class="flex justify-center gap-4 mb-6">
            <button id="Start" onclick="run()" class="bg-green-600 text-white px-4 py-2 rounded-md hover:bg-green-700 transition">Start</button>
            <button id="Stop" onclick="stop()" class="bg-red-600 text-white px-4 py-2 rounded-md hover:bg-red-700 transition">Stop</button>
            <div class="relative group">
                <button id="Scan" onclick="scanIP()" class="bg-blue-600 text-white px-4 py-2 rounded-md hover:bg-blue-700 transition">Scan</button>
                <span class="absolute hidden group-hover:block bg-gray-800 text-white text-xs rounded py-1 px-2 -mt-8 left-1/2 transform -translate-x-1/2">Use IP syntax with 1 wildcard: ###.###.###.*</span>
            </div>
        </div>

        <!-- Main Dashboard Grid -->
        <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">
            <!-- P1 Meter Section -->
            <section class="bg-white p-6 rounded-lg shadow-md">
                <h2 class="text-xl font-semibold text-gray-800 mb-4">P1 Meter</h2>
                <div class="space-y-2">
                    <p><span class="font-medium">IP:</span> <span id="IP_P1_001" class="text-gray-600"></span></p>
                    <p><span class="font-medium">WiFi SSID:</span> <span id="WifiSSID" class="text-gray-600"></span></p>
                    <p><span class="font-medium">WiFi Strength:</span> <span id="WifiStrength" class="text-gray-600">0%</span></p>
                    <p><span class="font-medium">Model:</span> <span id="MM" class="text-gray-600"></span></p>
                    <p><span class="font-medium">SMR Version:</span> <span id="SV" class="text-gray-600"></span></p>
                    <div class="grid grid-cols-2 gap-2">
                        <p><span class="font-medium text-green-600">Phase 1 (W):</span> <span id="P1">0</span> <span class="text-xs text-gray-500" id="P1d3">0</span> <span class="text-xs text-gray-500" id="P1d2">0</span> <span class="text-xs text-gray-500" id="P1d1">0</span></p>
                        <p><span class="font-medium text-yellow-600">Phase 2 (W):</span> <span id="P2">0</span> <span class="text-xs text-gray-500" id="P2d3">0</span> <span class="text-xs text-gray-500" id="P2d2">0</span> <span class="text-xs text-gray-500" id="P2d1">0</span></p>
                        <p><span class="font-medium text-purple-600">Phase 3 (W):</span> <span id="P3">0</span> <span class="text-xs text-gray-500" id="P3d3">0</span> <span class="text-xs text-gray-500" id="P3d2">0</span> <span class="text-xs text-gray-500" id="P3d1">0</span></p>
                        <p><span class="font-medium text-blue-600">Total (W):</span> <span id="PT">0</span> <span class="text-xs text-gray-500" id="PTd3">0</span> <span class="text-xs text-gray-500" id="PTd2">0</span> <span class="text-xs text-gray-500" id="PTd1">0</span></p>
                    </div>
                    <div class="grid grid-cols-2 gap-2">
                        <p><span class="font-medium">Export T1 (kWh):</span> <span id="ET1">0</span></p>
                        <p><span class="font-medium">Export T2 (kWh):</span> <span id="ET2">0</span></p>
                        <p><span class="font-medium">Import T1 (kWh):</span> <span id="IT1">0</span></p>
                        <p><span class="font-medium">Import T2 (kWh):</span> <span id="IT2">0</span></p>
                    </div>
                </div>
            </section>

            <!-- Water & kWh Meters Section -->
            <section class="bg-white p-6 rounded-lg shadow-md">
                <h2 class="text-xl font-semibold text-gray-800 mb-4">Water & kWh Meters</h2>
                <div class="space-y-4">
                    <div>
                        <h3 class="text-lg font-medium text-gray-700">Water Meter</h3>
                        <p><span class="font-medium">IP:</span> <span id="IP_W1_001" class="text-gray-600"></span></p>
                        <p><span class="font-medium">Active Usage (l/min):</span> <span id="AL" class="text-gray-600">0</span></p>
                        <p><span class="font-medium">Total (m³):</span> <span id="TL" class="text-gray-600">0</span></p>
                    </div>
                    <div>
                        <h3 class="text-lg font-medium text-gray-700">kWh Meter</h3>
                        <p><span class="font-medium">IP:</span> <span id="IP_KWH_001" class="text-gray-600"></span></p>
                        <p><span class="font-medium">Active Power (W):</span> <span id="KWH_PW" class="text-gray-600">0</span></p>
                        <p><span class="font-medium">Total Import (kWh):</span> <span id="KWH_IT1" class="text-gray-600">0</span></p>
                        <p><span class="font-medium">Total Export (kWh):</span> <span id="KWH_ET1" class="text-gray-600">0</span></p>
                    </div>
                </div>
            </section>

            <!-- Controls & Graphs Section -->
            <section class="bg-white p-6 rounded-lg shadow-md">
                <h2 class="text-xl font-semibold text-gray-800 mb-4">Controls & Graphs</h2>
                <div class="space-y-4">
                    <div class="flex items-center gap-2">
                        <button id="Zoom" onclick="toggleZoom()" class="bg-indigo-600 text-white px-3 py-1 rounded-md hover:bg-indigo-700 transition">Zoom</button>
                        <div class="flex-1">
                            <label class="block text-sm font-medium text-gray-700">Time Position (<span id="rangeValue_from">0</span>-<span id="rangeValue">10</span>)</label>
                            <input type="range" min="1" max="100" value="100" step="0.001" class="slider" id="myRange">
                        </div>
                        <div class="flex-1">
                            <label class="block text-sm font-medium text-gray-700">Points (<span id="pointsValue">10</span>)</label>
                            <input type="range" min="1" max="10" value="2" step="0.05" class="slider" id="myPoints">
                        </div>
                    </div>
                    <div>
                        <canvas le id="E" width="600" height="300" tabindex="1" class="border rounded-md"></canvas>
                        <draw-canvas-data-set class="absolute bg-gray-700 text-white text-sm p-2 rounded opacity-0 transition-opacity duration-300"></draw-canvas-data-set>
                    </div>
                </div>
            </section>

            <!-- Gas Graph & Table Section -->
            <section class="bg-white p-6 rounded-lg shadow-md col-span-1 lg:col-span-3">
                <h2 class="text-xl font-semibold text-gray-800 mb-4">Gas Usage</h2>
                <div class="flex items-center gap-4 mb-4">
                    <span class="text-sm font-medium text-gray-700">Show Gas Table</span>
                    <label class="switch">
                        <input id="tableSwitch_GAS" type="checkbox" checked onclick="tableSwitch_GAS()">
                        <span class="sliderB"></span>
                    </label>
                </div>
                <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
                    <div>
                        <canvas lg id="G" width="600" height="300" tabindex="2" class="border rounded-md"></canvas>
                        <draw-canvas-data-setG class="absolute bg-blue-500 text-white text-sm p-2 rounded opacity-0 transition-opacity duration-300"></draw-canvas-data-setG>
                    </div>
                    <div id="table_GAS" class="max-h-80 overflow-y-auto">
                        <table class="w-full text-sm text-left text-gray-700 border">
                            <thead class="bg-blue-100 sticky top-0">
                                <tr>
                                    <th class="p-2">Time</th>
                                    <th class="p-2">Gas (m³)</th>
                                    <th class="p-2">Delta Sum (L)</th>
                                    <th class="p-2">Delta (L)</th>
                                    <th class="p-2">Min.</th>
                                    <th class="p-2">Flow (L/min)</th>
                                </tr>
                            </thead>
                            <tbody id="TimeGasM3">
                                <tr><td class="p-2" colspan="6">No data yet</td></tr>
                            </tbody>
                        </table>
                    </div>
                </div>
            </section>

            <!-- Socket Tiles Section -->
            <section id="socketSection" class="bg-white p-6 rounded-lg shadow-md col-span-1 lg:col-span-3">
                <h2 class="text-xl font-semibold text-gray-800 mb-4">Smart Plugs (Sockets)</h2>
                <div id="socketTiles" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4"></div>
            </section>
        </div>
    </div>

    <script>
        var ip = {};
        let c = {};
        let h = 0;
        let w = 0;
        let Ctx = {};
        let CtxG = {};
        let dataX = [],
            dataXG = [],
            dataL_Total = [],
            datal1 = [],
            datal2 = [],
            datal3 = [];
        let dataGas = [],
            dataGasPoint = [];
        var un = 0;
        let xs = 0;
        let dataT = [];
        let button_stop = true;
        let tabE = {};
        let tabG = {};
        var zoomStatus = false;
        var sliderPercentage = 1;
        var sliderPoints = 10;
        let debug = false;
        var MMU = [];
        var tabIndexCanvas = 0;
        var tabIndeX_dataT = 0;
        const max_seconds = 60*60*24;
        let e_start = {};
        let e_stop = {};
        let e_scan = {};
        let _string = `<tr><th>Time (hh:mm:ss/dd-mm-yy)</th><th>Gas (m3)</th><th>DeltaSum(liter)</th><th>Delta (liter)</th><th>min.</th><th>Flow (liter/min )</th></tr>`;
        let min = 0,
            max = 0;
        let _s = 0;
        let _e = 0;
        let _index = 0;
        let _length = 0;

        var gVar = {};
        gVar.zoom = {
            s: 0,
            e: 0,
            zoomStatus: false,
            get zoom() {
                if (this.s == undefined) this.s = 0;
                if (this.e == undefined) this.e = dataX.length || 0;
                if (this.zoomStatus == undefined) this.zoomStatus = false;
                return {s: this.s, e: this.e, zoomStatus: this.zoomStatus};
            },
            set zoom(o) {
                this.s = o.s;
                this.e = o.e;
                this.zoomStatus = o.zoomStatus;
            }
        };

        var _k;
        let iteration = 0;

        // Socket-related variables
        let sockets = []; // Array to store detected sockets
        let socketData = {}; // Object to store power usage data for each socket

        function Init() {
            var slider = document.getElementById("myRange");
            var sliderP = document.getElementById("myPoints");
            var sliderTableSwitch = document.getElementById("tableSwitch_GAS");

            document.getElementById("pointsValue").innerHTML = sliderPoints;

            slider.oninput = function() {
                sliderPercentage = Number(this.value / 100);
                let _se = set_s_e(sliderPoints, sliderPercentage);
                _s = _se.s;
                _e = _se.e;
                document.getElementById("rangeValue").innerHTML = _e;
                document.getElementById("rangeValue_from").innerHTML = _s;
                document.getElementById("pointsValue").innerHTML = sliderPoints;
                if (button_stop) {
                    Ctx.clearRect(0, 0, w, h);
                    CtxG.clearRect(0, 0, wg, hg);
                    drawLine();
                }
            };

            sliderP.oninput = function() {
                sliderPoints = Math.floor(Math.exp(Number(this.value)));
                let _se = set_s_e(sliderPoints, sliderPercentage);
                _s = _se.s;
                _e = _se.e;
                document.getElementById("rangeValue").innerHTML = _e;
                document.getElementById("rangeValue_from").innerHTML = _s;
                document.getElementById("pointsValue").innerHTML = sliderPoints;
                if (button_stop) {
                    Ctx.clearRect(0, 0, w, h);
                    CtxG.clearRect(0, 0, wg, hg);
                    drawLine();
                }
            };

            _s = 0;
            _e = 0;
            zoomStatus = false;
            gVar.zoom = {s: _s, e: _e, zoomStatus: zoomStatus};

            if (e_start && e_start.style) e_start.style.opacity = 1;
            if (e_stop && e_stop.style) e_stop.style.opacity = 0;
            if (e_scan && e_scan.style) e_scan.style.opacity = 1;

            iteration = 0;
            dataX = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
            dataL_Total = [0, 100];
            un = Math.round((Math.max(...dataL_Total) - Math.min(...dataL_Total)) / 10);
            xs = (w - 80) / dataX.length;
            dataT = [];

            chart.setCtx(Ctx);
            chart.chartLine();
            chart.digram();

            chart.setCtx(CtxG);
            chart.chartLine();
            chart.digram();
        }

        function set_s_e(sliderPoints, sliderPercentage) {
            let _e = Math.floor(sliderPercentage * dataX.length);
            if (_e < 10) _e = 10;
            let _s = _e - sliderPoints;
            if (_s < 0 || _s == undefined) _s = 0;
            gVar.zoom = {s: _s, e: _e, zoomStatus: zoomStatus};
            if (debug) console.log(_s, _e, sliderPoints, sliderPercentage);
            return {s: _s, e: _e};
        }

        function tableSwitch_GAS() {
            let _checkBox = document.getElementById("tableSwitch_GAS").checked;
            let _container_GAS = document.getElementById("table_GAS");
            if (_checkBox && _container_GAS) {
                _container_GAS.style.display = "block";
            } else {
                _container_GAS.style.display = "none";
            }
        }

        // Function to generate socket tiles
        function generateSocketTiles() {
            const container = document.getElementById('socketTiles');
            container.innerHTML = ''; // Clear existing tiles

            if (sockets.length === 0) {
                container.innerHTML = '<p class="text-gray-600">No smart plugs detected.</p>';
                return;
            }

            sockets.forEach((socket, index) => {
                const tile = document.createElement('div');
                tile.className = 'bg-gray-50 p-4 rounded-lg shadow-sm';
                const powerUsage = socketData[socket.serial]?.powerUsage || [];
                const latestPower = powerUsage.length > 0 ? powerUsage[powerUsage.length - 1].toFixed(2) : '0.00';
                tile.innerHTML = `
                    <h3 class="text-lg font-semibold text-gray-800 mb-2">${socket.product_name} (${socket.serial})</h3>
                    <p class="text-sm text-gray-600">Firmware: ${socket.firmware_version}</p>
                    <p class="text-sm text-gray-600">Current Power Usage: <span id="powerUsage_${socket.serial}">${latestPower} W</span></p>
                    <canvas id="graph_${socket.serial}" height="100"></canvas>
                `;
                container.appendChild(tile);

                // Create graph for this socket
                const ctx = document.getElementById(`graph_${socket.serial}`).getContext('2d');
                new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: (socketData[socket.serial]?.timestamps || []).map(t => t.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', second: '2-digit' })),
                        datasets: [{
                            label: 'Power Usage (W)',
                            data: powerUsage,
                            borderColor: 'rgba(75, 192, 192, 1)',
                            borderWidth: 1,
                            fill: false,
                            pointRadius: 2
                        }]
                    },
                    options: {
                        scales: {
                            x: { display: true, title: { display: true, text: 'Time' }, ticks: { maxTicksLimit: 5 } },
                            y: { display: true, title: { display: true, text: 'Power (W)' }, beginAtZero: true }
                        },
                        plugins: { legend: { display: false } },
                        maintainAspectRatio: false
                    }
                });
            });
        }

        // Function to update socket data
        async function updateSocketData() {
            for (const socket of sockets) {
                const url = `http://${ip.SKT[socket.serial]}/api/v1/data`;
                try {
                    const response = await fetch(url);
                    if (response.ok) {
                        const json = await response.json();
                        if (!socketData[socket.serial]) {
                            socketData[socket.serial] = {
                                powerUsage: [],
                                timestamps: []
                            };
                        }
                        // Add new power usage data (e.g., active_power_w)
                        const power = json.active_power_w || 0;
                        socketData[socket.serial].powerUsage.push(power);
                        socketData[socket.serial].timestamps.push(new Date());
                        // Keep only the last 10 data points
                        if (socketData[socket.serial].powerUsage.length > 10) {
                            socketData[socket.serial].powerUsage.shift();
                            socketData[socket.serial].timestamps.shift();
                        }
                    }
                } catch (err) {
                    if (debug) console.log(`Failed to fetch data for socket ${socket.serial}:`, err);
                }
            }
            generateSocketTiles(); // Redraw tiles with updated data
        }

        window.onload = function() {
            e_start = document.getElementById('Start');
            e_stop = document.getElementById('Stop');
            e_scan = document.getElementById('Scan');

            if (e_start) e_start.style.opacity = 1;
            if (e_stop) e_stop.style.opacity = 0;
            if (e_scan && e_scan.style) e_scan.style.opacity = 1;

            c = document.querySelector("canvas[le]");
            cg = document.querySelector("canvas[lg]");

            tabE = document.querySelector("draw-canvas-data-set");
            tabG = document.querySelector("draw-canvas-data-setG");

            h = c.height;
            w = c.width;
            hg = cg.height;
            wg = cg.width;

            Ctx = c.getContext('2d');
            CtxG = cg.getContext('2d');

            cg.onmousemove = function(e) {
                document.getElementById('G').focus();
                tabE.style.opacity = "0";
                tabG.style.opacity = "0";
                mouseMove(e);
            };

            c.onmousemove = function(e) {
                tabE.style.opacity = "0";
                tabG.style.opacity = "0";
                document.getElementById('E').focus();
                mouseMove(e);
            };

            function mouseMove(e) {
                let _ID = e.currentTarget.attributes[1].nodeValue;
                tabIndexCanvas = e.currentTarget.attributes[4].nodeValue;
                _index = 0;

                _s = gVar.zoom.s;
                _e = gVar.zoom.e;
                zoomStatus = gVar.zoom.zoomStatus;

                if (_e == -1 || isNaN(_e)) {
                    _s = 0;
                    _e = dataX.length;
                    if (debug) console.log('correction');
                }
                gVar.zoom = {s: _s, e: _e, zoomStatus: zoomStatus};

                for (let data of dataT) {
                    for (const [key, value] of Object.entries(data)) {
                        let dataG = value.split(",");
                        let lx = Number(e.offsetX),
                            ly = Number(e.offsetY),
                            dx = Number(dataG[1]),
                            dy = Number(dataG[0]);
                        let _delta = Math.floor(Number(dataG[4]) / 3);
                        if (_delta < 10) _delta = 10;

                        if ((lx > dx - _delta && lx < dx + _delta) && (ly > dy - _delta && ly < dy + _delta)) {
                            if (_ID == 'E' && dataG[3] != 'Gas') {
                                tabE.innerHTML = dataG[3] + ':' + dataG[2];
                                tabE.style.opacity = "1";
                                tabE.style.left = e.layerX + "px";
                                tabE.style.top = e.layerY + "px";
                                if (debug) console.log(_index, Number(dataG[7]));
                                tabIndeX_dataT = Number(dataG[7]);
                            } else if (_ID == 'G' && dataG[3] == 'Gas') {
                                tabG.innerHTML = dataG[3] + ':' + dataG[2];
                                tabG.style.opacity = "1";
                                tabG.style.left = e.layerX + "px";
                                tabG.style.top = e.layerY + "px";
                            }
                        }
                        lx = lx - 1;
                        dx = dx - 1;
                    }
                    _index++;
                }
            }

            Init();
            document.getElementById('IP_P1').value = '192.168.2.*';
            document.getElementById('IP_KWH').value = '192.168.2.*';
            generateSocketTiles(); // Initial render of socket tiles
        };

        async function wrapper() {
            console.log('start');
            await waitInterval(meter, 999);
            console.log(iteration);
            button_stop = true;
            console.log('finish');
        }

        async function wrapperW() {
            console.log('start W');
            await waitInterval(meterW, 999);
            console.log(iteration);
            button_stop = true;
            console.log('finish W');
        }

        async function wrapperKWH() {
            console.log('start KWH');
            await waitInterval(meterKWH, 999);
            console.log(iteration);
            button_stop = true;
            console.log('finish KWH');
        }

        async function wrapperSKT() {
            console.log('start SKT');
            await waitInterval(meterSKT, 999);
            console.log(iteration);
            button_stop = true;
            console.log('finish SKT');
        }

        function toggleZoom() {
            zoomStatus = !zoomStatus;
            let _buttonZoom = document.getElementById("Zoom");
            if (zoomStatus) {
                _buttonZoom.classList.add("bg-indigo-800");
                _buttonZoom.classList.remove("bg-indigo-600");
            } else {
                _buttonZoom.classList.add("bg-indigo-600");
                _buttonZoom.classList.remove("bg-indigo-800");
            }

            if (gVar.zoom == undefined || gVar.zoom.s == undefined || gVar.zoom.e == 0) {
                if (sliderPercentage == undefined || sliderPercentage == 0) sliderPercentage = 1;
                _e = Math.floor(dataX.length * sliderPercentage);
                if (_e < 10) _e = 10;
                _s = _e - sliderPoints;
                if (_s < 0) _s = 0;
                gVar.zoom = {s: _s, e: _e, zoomStatus: zoomStatus};
            }

            // Update displayed slider values
            document.getElementById("rangeValue").innerHTML = _e;
            document.getElementById("rangeValue_from").innerHTML = _s;
            document.getElementById("pointsValue").innerHTML = sliderPoints;

            // Ensure redraw happens after zoom toggle
            Ctx.clearRect(0, 0, w, h);
            CtxG.clearRect(0, 0, wg, hg);
            drawLine();
        }

 
        function scanIP() {
    ip.P1 = document.getElementById('IP_P1').value;
    ip.WTR = document.getElementById('IP_WTR').value;
    ip.KWH = document.getElementById('IP_KWH').value;

    // Collect all IP ranges to scan
    const ipRanges = [];
    if (ip.P1) ipRanges.push({ base: ip.P1, type: 'P1' });
    if (ip.WTR) ipRanges.push({ base: ip.WTR, type: 'WTR' });
    if (ip.KWH) ipRanges.push({ base: ip.KWH, type: 'KWH' });

    // Scan each IP range
    ipRanges.forEach(async ({ base, type }) => {
        const hasWildcard = base.split('.')[3].includes('*');
        if (!hasWildcard) {
            // If no wildcard, try the exact IP
            console.log(`Trying exact IP for ${type}: ${base}`);
            await tryIP(base);
        } else {
            // If wildcard, scan the range
            console.log(`Scanning IP range for ${type}: ${base}`);
            for (let ii = 1; ii < 256; ii++) {
                const ipArray = base.split('.');
                ipArray[3] = ii;
                const newIp = ipArray.join('.');
                console.log(`Trying ${newIp}`);
                await tryIP(newIp);
            }
        }
    });
}

async function tryIP(_ip) {
    let url = 'http://' + _ip + '/api';
    const promise1 = new Promise((resolve, reject) => {
        console.log(`Fetching: ${url}`); // Always log the URL being tried
        fetch(url, { mode: 'no-cors' }) // Use no-cors mode to avoid CORS issues
            .then(async function(response) {
                // In no-cors mode, response.ok is always false, and we can't read the body
                // We need to make a second request to get the data
                const dataResponse = await fetch(url);
                if (dataResponse.ok) {
                    let _json = await dataResponse.json();
                    console.log(`Response from ${_ip}:`, _json);
                    if (_json.product_type == "HWE-P1") {
                        ip.P1 = _ip;
                        document.getElementById('IP_P1').value = ip.P1;
                        console.log('Found HWE-P1', url, ip.P1);
                        resolve();
                    }
                    if (_json.product_type == "HWE-WTR") {
                        ip.WTR = _ip;
                        document.getElementById('IP_WTR').value = ip.WTR;
                        console.log('Found HWE-WTR', url, ip.WTR);
                        resolve();
                    }
                    if (_json.product_type.includes("HWE-KWH") || _json.product_type.includes("SDM")) {
                        ip.KWH = _ip;
                        document.getElementById('IP_KWH').value = ip.KWH;
                        console.log('Found kWh-Meter', url, ip.KWH);
                        resolve();
                    }
                    if (_json.product_type == "HWE-SKT") {
                        if (!ip.SKT) ip.SKT = {};
                        ip.SKT[_json.serial] = _ip;
                        sockets.push(_json);
                        console.log('Found HWE-SKT', url, _json.serial);
                        generateSocketTiles();
                        resolve();
                    }
                    reject(new Error('Device type not recognized'));
                } else {
                    reject(new Error(`HTTP Error: ${dataResponse.status}`));
                }
            })
            .catch((err) => {
                console.error(`Fetch error for ${_ip}:`, err);
                reject(err);
            });
    });
    const promise2 = new Promise((resolve, reject) => setTimeout(() => reject(new Error('Timeout')), 1000)); // Increased timeout to 1000ms
    try {
        await Promise.race([promise1, promise2]);
    } catch (e) {
        console.log(`Failed to connect to ${_ip}: ${e.message}`);
    }
}
  

        function setHoverText() {
            let _hover = document.getElementsByClassName('group')[0];
            if (_hover) {
                if (!button_stop) {
                    _hover.style.display = 'none';
                } else {
                    _hover.style.display = 'inline-block';
                }
            }
        }

        function fill_data_random() {
            let _i = 600;
            let _interval = 1;

            set_s_e(sliderPoints, sliderPercentage);
            document.getElementById("rangeValue").innerHTML = _i;

            gVar.zoom = {s: 1, e: _i, zoomStatus};
            dataX = [];
            for (let iii = 1; iii < _i; iii++) {
                dataX.push(iii);
                let ran1 = Math.random();
                let ran2 = Math.random();
                let ran3 = Math.random();
                let _l1 = Math.floor(ran1 * 400);
                let _l2 = Math.floor(ran2 * 400);
                let _l3 = Math.floor(ran3 * 400);
                let _tot = _l1 + _l2 + _l3;
                if (_l1 != undefined && _l2 != undefined && _l3 != undefined) {
                    datal1.push(_l1);
                    datal2.push(_l2);
                    datal3.push(_l3);
                    dataL_Total.push(_tot);
                }
            }
            dataXG = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

            dataGas = [
                ['21:10:06/22-11-22', 3037.961, 76206],
                ['21:10:06/22-11-22', 3037.961, 76206],
                ['21:10:06/22-11-22', 3037.961, 76206],
                ['21:15:05/22-11-22', 3038.991, 76505],
                ['21:15:05/22-11-22', 3038.991, 76505],
                ['21:15:05/22-11-22', 3038.991, 76505],
                ['21:20:05/22-11-22', 3039.991, 76505],
                ['21:20:05/22-11-22', 3039.991, 76505]
            ];

            dataGasPoint = [
                ["18:10:00/22-11-22", 2000.101, 75005, 2, 5, 0.4],
                ["18:10:00/22-11-22", 2000.108, 75305, 125, 5, 25],
                ["18:10:00/22-11-22", 2000.150, 75605, 100, 5, 20],
                ["18:10:00/22-11-22", 2000.200, 75905, 0.0, 5, 0],
                ["18:10:00/22-11-22", 2000.202, 76205, 28, 5, 15],
                ["18:10:00/22-11-22", 2000.205, 76505, 255, 5, 50],
                ["18:10:00/22-11-22", 2001.206, 76805, 25, 5, 5],
                ["18:10:00/22-11-22", 2001.209, 77105, 133, 5, 25]
            ];

            // Simulate socket data for testing
            sockets = [
                { product_type: "HWE-SKT", product_name: "Energy Socket", serial: "SN001", firmware_version: "3.02", api_version: "v1" },
                { product_type: "HWE-SKT", product_name: "Energy Socket", serial: "SN002", firmware_version: "3.02", api_version: "v1" }
            ];
            sockets.forEach(socket => {
                if (!ip.SKT) ip.SKT = {};
                ip.SKT[socket.serial] = `192.168.2.${Math.floor(Math.random() * 255)}`; // Simulate IP for testing
                socketData[socket.serial] = {
                    powerUsage: Array(10).fill(0).map(() => Math.random() * 100),
                    timestamps: Array(10).fill(0).map((_, i) => new Date(Date.now() - (9 - i) * 60 * 1000))
                };
            });
            generateSocketTiles();
        }

        function run() {
            button_stop = false;
            setHoverText();
            ip.P1 = document.getElementById('IP_P1').value;
            ip.WTR = document.getElementById('IP_WTR').value;
            ip.KWH = document.getElementById('IP_KWH').value;

            if (ip.KWH && !ip.KWH.includes('*')) {
                wrapperKWH();
            }
            if (ip.WTR && !ip.WTR.includes('*')) {
                wrapperW();
            }
            if (ip.SKT) {
                wrapperSKT();
            }
            if (ip.P1 && !ip.P1.includes('*')) {
                Init();
                if (e_start) e_start.style.opacity = 0;
                if (e_stop) e_stop.style.opacity = 1;
                if (e_scan && e_scan.style) e_scan.style.opacity = 0;
                dataX = [];
                dataXG = [];
                dataL_Total = [];
                datal1 = [];
                datal2 = [];
                datal3 = [];
                dataT = [];
                dataGas = [];
                dataGasPoint = [];
                iteration = 1;
                wrapper();
            } else {
                fill_data_random();
                iteration = 1;
                Ctx.clearRect(0, 0, w, h);
                CtxG.clearRect(0, 0, wg, hg);
                drawLine();
                button_stop = true;
                writeNumbers_E({
                    'active_power_w': dataL_Total[dataL_Total.length-1],
                    'active_power_l1_w': datal1[dataL_Total.length-1],
                    'active_power_l2_w': datal2[dataL_Total.length-1],
                    'active_power_l3_w': datal3[dataL_Total.length-1],
                    'total_gas_m3': dataGasPoint[dataGasPoint.length-1],
                    'total_power_export_t1_kwh': 1234,
                    'total_power_export_t2_kwh': 0123,
                    'total_power_import_t1_kwh': 987,
                    'total_power_import_t2_kwh': 321
                });
            }
        }

        function stop() {
            button_stop = true;
            setHoverText();
            if (e_start) e_start.style.opacity = 1;
            if (e_stop) e_stop.style.opacity = 0;
            if (e_scan && e_scan.style) e_scan.style.opacity = 1;
        }

        async function meter(i) {
            iteration = i;
            let url = 'http://' + ip.P1 + '/api/v1/data';
            let response = await fetch(url);

            if (response.ok) {
                let json = await response.json();

                if (isNaN(json.active_power_w)) json.active_power_w = 0;
                if (isNaN(json.active_power_l1_w)) json.active_power_l1_w = 0;
                if (isNaN(json.active_power_l2_w)) json.active_power_l2_w = 0;
                if (isNaN(json.active_power_l3_w)) json.active_power_l3_w = 0;
                dataL_Total.push(json.active_power_w);
                datal1.push(json.active_power_l1_w);
                datal2.push(json.active_power_l2_w);
                datal3.push(json.active_power_l3_w);
                dataX.push(i);

                document.getElementById('IP_P1_001').innerHTML = ip.P1;
                document.getElementById('WifiSSID').innerHTML = json.wifi_ssid;
                document.getElementById('WifiStrength').innerHTML = json.wifi_strength;
                document.getElementById('MM').innerHTML = json.meter_model;
                document.getElementById('SV').innerHTML = json.smr_version;

                writeNumbers_E(json);

                // Update socket data
                await updateSocketData();

                Ctx.clearRect(0, 0, w, h);
                CtxG.clearRect(0, 0, wg, hg);
                drawLine();

                if (sliderPercentage == 1) {
                    document.getElementById("rangeValue").innerHTML = dataX.length;
                }

                if (json.gas_timestamp) {
                    let _stamp = json.gas_timestamp.toString();
                    let hh = _stamp.substring(6, 8);
                    let mm = _stamp.substring(8, 10);
                    let ss = _stamp.substring(10, 12);
                    let DD = _stamp.substring(4, 6);
                    let MM = _stamp.substring(2, 4);
                    let YY = _stamp.substring(0, 2);

                    let _time = hh + ':' + mm + ':' + ss;
                    let _date = DD + '-' + MM + '-' + YY;
                    _time = _time + '/' + _date;

                    let _timestamp = (new Date('20' + YY + '-' + MM + '-' + DD + 'T' + hh + ':' + mm + ':' + ss)).getTime();
                    if (debug) console.log(new Date(_timestamp), _timestamp);
                    let _deltaGas = 0;
                    let _min = 0;
                    let _usage = 0;

                    if (dataGasPoint.length != 0) {
                        if (dataGasPoint[dataGasPoint.length - 1][2] != _timestamp || debug == true) {
                            if (debug) console.log(hh, mm, ss, _time, _timestamp);
                            let _startGas = dataGasPoint[0][1];
                            let _deltaSum = ((Math.floor(json.total_gas_m3 * 1000) - Math.floor(_startGas * 1000)) * 1000) / 1000;

                            _string = _string + '<tr><td class="p-2">' + _time + '</td>';
                            if (dataGasPoint.length > 0) {
                                _deltaGas = Math.floor((json.total_gas_m3 * 1000 - dataGasPoint[dataGasPoint.length - 1][1] * 1000) * 1000) / 1000;
                                _min = (_timestamp - dataGasPoint[dataGasPoint.length - 1][2]) / 60000;
                                _string = _string + '<td class="p-2">' + json.total_gas_m3 + '</td><td class="p-2">' + _deltaSum + '</td><td class="p-2">' + _deltaGas + '</td><td class="p-2">' + Math.floor(_min * 10) / 10 + '</td>';
                                if (_min != 0) {
                                    _usage = Math.round(_deltaGas * 100 / _min) / 100;
                                    _string = _string + '<td class="p-2">' + _usage + '</td>';
                                }
                            }
                            _string = _string + '</tr>';

                            dataGasPoint.push([_time, json.total_gas_m3, _timestamp, _deltaGas, _min, _usage]);
                            dataXG.push(i);
                        }
                    } else {
                        dataGas.push([_time, json.total_gas_m3, _timestamp]);
                        dataGasPoint.push([_time, json.total_gas_m3, _timestamp, null, null, null]);
                        dataXG.push(i);
                        _string = _string + '<tr><td class="p-2">' + _time + '<td class="p-2">' + json.total_gas_m3 + '</td></tr>';
                    }

                    _k = object('#TimeGasM3');
                    _k.innerHTML = _string;
                }

                let _return = (i == max_seconds || button_stop);
                if (_return) stop();
                return _return;
            } else {
                alert("HTTP-Error: " + response.status);
            }
        }

        async function meterW(iW) {
            iteration = iW;
            let url = 'http://' + ip.WTR + '/api/v1/data';
            let response = await fetch(url);

            if (response.ok) {
                let json = await response.json();
                document.getElementById('IP_W1_001').innerHTML = ip.WTR;
                if (json.active_liter_lpm) {
                    document.getElementById('AL').innerHTML = json.active_liter_lpm;
                    document.getElementById('TL').innerHTML = json.total_liter_m3;
                } else {
                    document.getElementById('AL').innerHTML = '';
                    document.getElementById('TL').innerHTML = '';
                }

                let _return = (iW == max_seconds || button_stop);
                if (_return) stop();
                return _return;
            } else {
                alert("HTTP-Error: " + response.status);
            }
        }

        async function meterKWH(iKWH) {
            iteration = iKWH;
            let url = 'http://' + ip.KWH + '/api/v1/data';
            let response = await fetch(url);

            if (response.ok) {
                let json = await response.json();
                document.getElementById('IP_KWH_001').innerHTML = ip.KWH;
                document.getElementById('KWH_PW').innerHTML = json.active_power_w || 0;
                document.getElementById('KWH_IT1').innerHTML = json.total_power_import_t1_kwh || 0;
                document.getElementById('KWH_ET1').innerHTML = json.total_power_export_t1_kwh || 0;

                let _return = (iKWH == max_seconds || button_stop);
                if (_return) stop();
                return _return;
            } else {
                alert("HTTP-Error: " + response.status);
            }
        }

        async function meterSKT(iSKT) {
            iteration = iSKT;
            await updateSocketData();
            let _return = (iSKT == max_seconds || button_stop);
            if (_return) stop();
            return _return;
        }

        function writeNumbers_E(json) {
            document.getElementById('P1').innerHTML = json.active_power_l1_w;
            if (json.active_power_l2_w) {
                document.getElementById('P2').innerHTML = json.active_power_l2_w;
            } else {
                document.getElementById('P2').innerHTML = '';
            }
            if (json.active_power_l3_w) {
                document.getElementById('P3').innerHTML = json.active_power_l3_w;
            } else {
                document.getElementById('P3').innerHTML = '';
            }
            document.getElementById('PT').innerHTML = json.active_power_w;

            let deltas = delta_calc(dataL_Total);
            document.getElementById('PTd3').innerHTML = deltas[0];
            document.getElementById('PTd2').innerHTML = deltas[1];
            document.getElementById('PTd1').innerHTML = deltas[2];
            let deltal1 = delta_calc(datal1);
            document.getElementById('P1d3').innerHTML = deltal1[0];
            document.getElementById('P1d2').innerHTML = deltal1[1];
            document.getElementById('P1d1').innerHTML = deltal1[2];
            let deltal2 = delta_calc(datal2);
            document.getElementById('P2d3').innerHTML = deltal2[0];
            document.getElementById('P2d2').innerHTML = deltal2[1];
            document.getElementById('P2d1').innerHTML = deltal2[2];
            let deltal3 = delta_calc(datal3);
            document.getElementById('P3d3').innerHTML = deltal3[0];
            document.getElementById('P3d2').innerHTML = deltal3[1];
            document.getElementById('P3d1').innerHTML = deltal3[2];

            document.getElementById('ET1').innerHTML = json.total_power_export_t1_kwh;
            document.getElementById('ET2').innerHTML = json.total_power_export_t2_kwh;
            document.getElementById('IT1').innerHTML = json.total_power_import_t1_kwh;
            document.getElementById('IT2').innerHTML = json.total_power_import_t2_kwh;
        }

        async function waitInterval(callback, ms) {
            return new Promise(resolve => {
                const interval = setInterval(async () => {
                    if (await callback(iteration, interval)) {
                        resolve();
                        clearInterval(interval);
                        return true;
                    }
                    iteration++;
                }, ms);
            });
        }

        function delta_calc(_array) {
            let delta = [];
            if (_array.length > 3) {
                delta.push(_array[_array.length - 1] - _array[_array.length - 4]);
            } else {
                delta.push(0);
            }
            if (_array.length > 2) {
                delta.push(_array[_array.length - 1] - _array[_array.length - 3]);
            } else {
                delta.push(0);
            }
            if (_array.length > 1) {
                delta.push(_array[_array.length - 1] - _array[_array.length - 2]);
            } else {
                delta.push(0);
            }
            return delta;
        }

        function $(object) {
            return document.querySelector(object);
        }

        function object(object) {
            return document.querySelector(object);
        }

        function leftPad(number, targetLength) {
            var output = number + '';
            while (output.length < targetLength) {
                output = '0' + output;
            }
            return output;
        }

        function getMinMaxUn(AA) {
            min = 0;
            max = 0;

            if (AA.length >= 1) {
                if (Array.isArray(AA[0])) {
                    let maxArray = AA.map(a => Math.max.apply(null, a));
                    max = Math.max(...maxArray);
                    let minArray = AA.map(a => Math.min.apply(null, a));
                    min = Math.min(...minArray);
                } else {
                    max = Math.max(...AA);
                    min = Math.min(...AA);
                }
            }

            if (min == max) {
                if ((max - min) > 10) {
                    min = AA[0] * 0.999;
                    max = AA[0] * 1.001;
                } else {
                    min = 0;
                    max = AA[0] * 1.01;
                }
            }

            // Add padding to min and max (10% of the range)
            let range = max - min;
            let padding = range * 0.1;
            max = max + padding;
            min = min - padding;

            un = (max - min) / 10;

            if (un >= 1000) {
                max = Math.ceil(max / 5000) * 5000;
                min = Math.floor(min / 5000) * 5000;
                un = (max - min) / 10;
            } else if (un >= 100) {
                max = Math.ceil(max / 500) * 500;
                min = Math.floor(min / 500) * 500;
                un = (max - min) / 10;
            } else if (un >= 10) {
                max = Math.ceil(max / 50) * 50;
                min = Math.floor(min / 50) * 50;
                un = (max - min) / 10;
            } else if (un >= 1) {
                max = Math.ceil(max / 10) * 10;
                min = Math.floor(min / 10) * 10;
                un = (max - min) / 10;
            } else if (un >= 0) {
                max = Math.ceil(max * 1) / 1;
                min = Math.floor(min * 1) / 1;
                un = (max - min) / 10;
            }

            if (un == 0) { un = 0.1; max = 10; min = 0; }

            if (debug) console.log(min, max, un);
            return [min, max, un];
        }

        function drawLine() {
            if (dataL_Total.length != 0) {
                if (zoomStatus) {
                    _s = gVar.zoom.s;
                    _e = gVar.zoom.e;
                    if (sliderPercentage == 1) {
                        _e = dataX.length;
                        _s = _e - sliderPoints;
                        if (_s < 0) _s = 0;
                    }
                } else {
                    _s = 0;
                    _e = dataX.length;
                }
                gVar.zoom = {s: _s, e: _e, zoomStatus: zoomStatus};
                _length = _e - _s;

                let A = [dataL_Total.slice(_s, _e), datal1.slice(_s, _e), datal2.slice(_s, _e), datal3.slice(_s, _e)];
                MMU[0] = getMinMaxUn(A);
                min = MMU[0][0];
                max = MMU[0][1];
                un = MMU[0][2];

                xs = (w - 80) / _length;

                dataT = [];
                chart.setCtx(Ctx);
                chart.chartLine();
                chart.digram();
                chart.data();
                chart.draw();
                chart.pointes();
            }

            if (dataGasPoint.length != 0) {
                let datag = [];
                for (let datagas of dataGasPoint) {
                    datag.push(datagas[5]);
                }

                _s = 0;
                _e = dataX.length;

                MMU[1] = getMinMaxUn(datag);
                MMU[1][0] = min = 0;
                max = MMU[1][1];
                un = MMU[1][2];

                xs = (w - 80) / dataXG.length;
                chart.setCtx(CtxG);
                chart.chartLine();
                chart.digram();
                chart.dataGas();
                chart.drawG();
                chart.pointesGas();
            }

            return true;
        }

        var chart = {
            ctx: {},
            setCtx: function(_ctx) {
                this.ctx = _ctx;
            },
            setStrokeStyle: function(_color) {
                this.ctx.strokeStyle = _color;
            },
            digram: function() {
                x = 60;
                y = 1;
                this.ctx.strokeStyle = "#a7a7a7";
                while (x < w) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(x, 0);
                    this.ctx.lineTo(x, h - 30);
                    this.ctx.stroke();
                    x += 30;
                }
                while (y < h - 30) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(60, y);
                    this.ctx.lineTo(w, y);
                    this.ctx.stroke();
                    y += 30;
                }
            },
            chartLine: function() {
                this.ctx.strokeStyle = "#000";
                this.ctx.beginPath();
                this.ctx.moveTo(60, 0);
                this.ctx.lineTo(60, h - 30);
                this.ctx.stroke();

                this.ctx.beginPath();
                this.ctx.moveTo(w, h - 30);
                this.ctx.lineTo(60, h - 30);
                this.ctx.stroke();
            },
            draw: function() {
                this.ctx.save();
                this.ctx.strokeStyle = "#0b95d3";
                this.ctx.lineWidth = 4;
                this.ctx.beginPath();
                x = 60;
                line = 30;

                // Calculate the y-coordinate scaling factor based on the canvas height
                let yRange = max - min;
                let yScale = (h - 60) / yRange; // h-60 to account for top and bottom margins (30 each)

                for (let ix = _s; ix < _e; ix++) {
                    const data = dataL_Total[ix];
                    y = h - 30 - (data - min) * yScale; // Map data to canvas y-coordinate
                    this.ctx.lineTo(x, y);
                    x += xs;
                }
                this.ctx.stroke();

                this.setStrokeStyle("#00FF00");
                this.ctx.lineWidth = 3;
                this.ctx.beginPath();
                x = 60;
                for (let ix = _s; ix < _e; ix++) {
                    const data = datal1[ix];
                    y = h - 30 - (data - min) * yScale;
                    this.ctx.lineTo(x, y);
                    x += xs;
                }
                this.ctx.stroke();

                this.setStrokeStyle("#d6d610");
                this.ctx.lineWidth = 3;
                this.ctx.beginPath();
                x = 60;
                for (let ix = _s; ix < _e; ix++) {
                    const data = datal2[ix];
                    y = h - 30 - (data - min) * yScale;
                    this.ctx.lineTo(x, y);
                    x += xs;
                }
                this.ctx.stroke();

                this.setStrokeStyle("#A020F0");
                this.ctx.lineWidth = 3;
                this.ctx.beginPath();
                x = 60;
                for (let ix = _s; ix < _e; ix++) {
                    const data = datal3[ix];
                    y = h - 30 - (data - min) * yScale;
                    this.ctx.lineTo(x, y);
                    x += xs;
                }
                this.ctx.stroke();
                this.ctx.restore();
            },
            drawG: function() {
                this.ctx.save();
                this.ctx.strokeStyle = "#0b95d3";
                this.ctx.lineWidth = 3;
                this.ctx.beginPath();
                x = 60;
                line = 30;

                if (dataGasPoint.length === 0) {
                    this.ctx.restore();
                    return;
                }

                let yRange = MMU[1][1] - MMU[1][0];
                let yScale = (h - 60) / yRange;

                let firstData = dataGasPoint[0][5];
                let firstY = h - 30 - (firstData - MMU[1][0]) * yScale;
                this.ctx.moveTo(x, firstY);

                for (let i = 0; i < dataGasPoint.length; i++) {
                    const data = dataGasPoint[i][5];
                    y = h - 30 - (data - MMU[1][0]) * yScale;
                    this.ctx.lineTo(x, y);
                    x += xs;
                }

                this.ctx.stroke();
                this.ctx.restore();
            },
            pointes: function() {
                let _indexL = 0;
                this.ctx.fillStyle = "#0b95d3";
                x = 60;
                line = 30;

                let yRange = max - min;
                let yScale = (h - 60) / yRange;

                for (let ix = _s; ix < _e; ix++) {
                    const data = dataL_Total[ix];
                    this.points(data, dataL_Total, 'Tot.', _indexL, yScale);
                    _indexL++;
                }

                _indexL = 0;
                this.ctx.fillStyle = "#00FF00";
                x = 60;
                for (let ix = _s; ix < _e; ix++) {
                    const data = datal1[ix];
                    this.points(data, datal1, 'l1', _indexL, yScale);
                    _indexL++;
                }

                _indexL = 0;
                this.ctx.fillStyle = "#d6d610";
                x = 60;
                for (let ix = _s; ix < _e; ix++) {
                    const data = datal2[ix];
                    this.points(data, datal2, 'l2', _indexL, yScale);
                    _indexL++;
                }

                _indexL = 0;
                this.ctx.fillStyle = "#A020F0";
                x = 60;
                for (let ix = _s; ix < _e; ix++) {
                    const data = datal3[ix];
                    this.points(data, datal3, 'l3', _indexL, yScale);
                    _indexL++;
                }
                this.ctx.fillStyle = "#00000F";
                this.ctx.stroke();
            },
            points: function(d, dX, f, _indX, yScale) {
                y = h - 30 - (d - min) * yScale;
                this.circle(x, y);
                dataT.push({d: Math.round(y) + "," + Math.round(x) + "," + Math.round(d) + "," + f + "," + MMU[0] + ',' + Number(_indX)});
                x += xs;
            },
            pointesGas: function() {
                this.ctx.fillStyle = "#0b95d3";
                x = 60;
                line = 30;

                let yRange = MMU[1][1] - MMU[1][0];
                let yScale = (h - 60) / yRange;

                let _indexG = 0;
                for (let data of dataGasPoint) {
                    this.pointsGas(data[5], dataGasPoint, 'Gas', _indexG, yScale);
                    _indexG++;
                }

                this.ctx.fillStyle = "#00000F";
                this.ctx.stroke();
            },
            pointsGas: function(d, dX, f, _indG, yScale) {
                y = h - 30 - (d - MMU[1][0]) * yScale;
                this.circle(x, y);
                dataT.push({d: Math.round(y) + "," + Math.round(x) + "," + Math.round(d * 10) / 10 + "," + f + "," + MMU[1] + ',' + Number(_indG)});
                x += xs;
            },
            data: function() {
                x = 60;
                y = 30;
                n = max;

                let _factor = 1;
                if (zoomStatus) {
                    _s = gVar.zoom.s;
                    _e = gVar.zoom.e;
                } else {
                    _s = 0;
                    _e = dataX.length;
                }
                _length = _e - _s;

                if (_length > 24000) {
                    _factor = Math.floor(_length / 3600);
                    if (_factor < 3600) _factor = 3600;
                } else if (_length > 6000) {
                    _factor = Math.floor(_length / 1200);
                    if (_factor < 1200) _factor = 1200;
                } else if (_length > 1200) {
                    _factor = Math.floor(_length / 240);
                    if (_factor < 240) _factor = 240;
                } else if (_length > 300) {
                    _factor = Math.floor(_length / 60);
                    if (_factor < 60) _factor = 60;
                } else if (_length > 20) {
                    _factor = Math.floor(_length / 10);
                    if (_factor < 1) _factor = 1;
                }

                let xi = 0;
                for (let ix = _s; ix < _e; ix++) {
                    const xdata = dataX[ix];
                    this.ctx.font = "12px Arial";

                    if (xdata > 3600) {
                        if ((xi % _factor) == 0) {
                            this.ctx.fillText(
                                (Math.floor(xdata / 3600)) + ':' +
                                leftPad(Math.floor((xdata - 3600 * (Math.floor(xdata / 3600))) / 60), 2) + ':' +
                                leftPad((xdata - (60 * Math.floor(xdata / 60))) % 60, 2),
                                x, h - 10
                            );
                        }
                    } else if (xdata > 60) {
                        if ((xi % _factor) == 0) {
                            this.ctx.fillText(
                                (Math.floor(xdata / 60)) + ':' +
                                leftPad((xdata - (60 * Math.floor(xdata / 60))) % 60, 2),
                                x, h - 10
                            );
                        }
                    } else {
                        if ((xi % _factor) == 0) {
                            this.ctx.fillText(xdata + 's', x, h - 10);
                        }
                    }
                    x += xs;
                    xi++;
                }

                let yRange = max - min;
                let yStep = yRange / 10; // Divide the range into 10 steps
                let yPos = 30;
                let yValue = max;
                while (yPos <= h - 30) {
                    this.ctx.font = "11px Arial";
                    this.ctx.fillText(Math.round(yValue), 0, yPos + 5);
                    yValue -= yStep;
                    yPos += 30;
                }
            },
            dataGas: function() {
                x = 60;
                y = 30;
                n = max;

                for (let xdata of dataXG) {
                    this.ctx.font = "12px Arial";
                    if (dataXG.length > 300) {
                        this.ctx.fillText(xdata * 60, x + 60 * xs - xs, h - 10);
                        x += xs * 60;
                    } else if (dataXG.length > 140) {
                        this.ctx.fillText(xdata * 20, x + 20 * xs - xs, h - 10);
                        x += xs * 20;
                    } else if (dataXG.length > 50) {
                        this.ctx.fillText(xdata * 10, x + 10 * xs - xs, h - 10);
                        x += xs * 10;
                    } else if (dataXG.length > 20) {
                        this.ctx.fillText(xdata * 5, x + 5 * xs - xs, h - 10);
                        x += xs * 5;
                    } else if (dataXG.length > 10) {
                        this.ctx.fillText(xdata * 2, x + 2 * xs - xs, h - 10);
                        x += xs * 2;
                    } else {
                        this.ctx.fillText(xdata, x, h - 10);
                        x += xs;
                    }
                }
                while (y < h - 30) {
                    this.ctx.font = "11px Arial";
                    this.ctx.fillText(n, 0, y + 5);
                    n = n - un;
                    n = Math.floor(n * 100) / 100;
                    y += 30;
                }
            },
            circle: function(x, y) {
                this.ctx.beginPath();
                this.ctx.arc(x, y, 4, 0, 2 * Math.PI);
                this.ctx.fill();
            }
        };
    </script>
</body>
</html>